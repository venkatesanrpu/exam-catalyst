<?php
/**
 * MCQ Widget AJAX Endpoint (Flashcard JSON Response)
 * FILE: blocks/ai_assistant/ajax/mcq_widget_ajax.php
 * PURPOSE: Generate MCQs via non-streaming, parse text to JSON, store JSON only
 * VERSION: Production - With level-specific prompts using Main Subject Key prefix
 */

define('AJAX_SCRIPT', true);

require_once(__DIR__ . '/../../../config.php');
require_once($CFG->dirroot . '/local/ai_functions/lib.php');

require_login();
require_sesskey();

header('Content-Type: application/json');
header('Cache-Control: no-cache');

while (ob_get_level() > 0) {
    ob_end_clean();
}

set_time_limit(240);
ini_set('max_execution_time', 240);

try {
    global $DB, $USER, $CFG;
    
    // ==================== GET PARAMETERS ====================
    
    $agentkey = required_param('agent_config_key', PARAM_ALPHANUMEXT);
    $level = required_param('level', PARAM_ALPHA);
    $agenttext = required_param('agent_text', PARAM_RAW);
    $mainsubjectkey = required_param('mainsubject', PARAM_ALPHANUMEXT); // From block config
    $target = optional_param('target', 'CSIR Chemical Sciences Exam', PARAM_TEXT);
    $subject = optional_param('subject', 'Chemistry', PARAM_TEXT);
    $topic = optional_param('topic', '', PARAM_TEXT);
    $lesson = optional_param('lesson', '', PARAM_TEXT);
    $tags = optional_param('tags', '', PARAM_RAW);
    $courseid = required_param('courseid', PARAM_INT);
    
    // NEW: Core and related concepts (optional)
    $core_concepts = optional_param('core_concepts', '[]', PARAM_RAW);
    $related_concepts = optional_param('related_concepts', '[]', PARAM_RAW);
    
    // Decode JSON arrays
    $core_concepts_array = json_decode($core_concepts, true) ?? [];
    $related_concepts_array = json_decode($related_concepts, true) ?? [];
    
    // Validate level
    $valid_levels = ['basic', 'intermediate', 'advanced'];
    if (!in_array($level, $valid_levels)) {
        throw new Exception('Invalid level: ' . $level);
    }
    
    error_log("MCQ Widget - Main Subject Key: {$mainsubjectkey}, Level: {$level}");
    
    // ==================== DETERMINE QUESTION COUNT & INSTRUCTION FILE ====================
    
    $question_count = 5; // Default
    $mcqinstruction = '';
    
    switch ($level) {
        case 'basic':
            $question_count = 10;
            $mcqinstruction = "{$mainsubjectkey}_mcq_basic.txt";
            break;
            
        case 'intermediate':
            $question_count = 10;
            $mcqinstruction = "{$mainsubjectkey}_mcq_intermediate.txt";
            break;
            
        case 'advanced':
            $question_count = 5;
            $mcqinstruction = "{$mainsubjectkey}_mcq_advanced.txt";
            break;
            
        default:
            $question_count = 5;
            $mcqinstruction = "{$mainsubjectkey}_mcq_basic.txt";
            break;
    }
    
    // ==================== LOAD INSTRUCTION FILE WITH FALLBACK ====================
    
    $prompt_file = $CFG->dirroot . "/blocks/ai_assistant/prompts/{$mcqinstruction}";
    
    // Fallback to CSIRCHEM if subject-specific file doesn't exist
    if (!file_exists($prompt_file)) {
        error_log("MCQ Widget - Subject-specific prompt not found: {$mcqinstruction}, trying CSIRCHEM fallback");
        $mcqinstruction = str_replace($mainsubjectkey, 'CSIRCHEM', $mcqinstruction);
        $prompt_file = $CFG->dirroot . "/blocks/ai_assistant/prompts/{$mcqinstruction}";
    }
    
    // Final fallback to legacy single file
    if (!file_exists($prompt_file)) {
        error_log("MCQ Widget - Level-specific prompt not found, using legacy mcq_instruction.txt");
        $prompt_file = $CFG->dirroot . '/blocks/ai_assistant/prompts/mcq_instruction.txt';
        $mcqinstruction = 'mcq_instruction.txt';
    }
    
    if (!file_exists($prompt_file)) {
        throw new Exception('MCQ prompt template not found');
    }
    
    error_log("MCQ Widget - Using prompt file: {$mcqinstruction}");
    
    $prompt_template = file_get_contents($prompt_file);
    
    // ==================== REPLACE PLACEHOLDERS ====================
    
    $core_concepts_str = !empty($core_concepts_array) 
        ? implode(', ', $core_concepts_array) 
        : 'Not specified';
    
    $related_concepts_str = !empty($related_concepts_array) 
        ? implode(', ', $related_concepts_array) 
        : 'Not specified';
    
    $placeholders = [
        '{QUESTION_COUNT}' => $question_count,
        '{TARGET_EXAM}' => $target,
        '{SUBJECT}' => $subject,
        '{TOPIC}' => $topic,
        '{LESSON}' => $lesson,
        '{LEVEL}' => strtolower($level),
        '{AGENT_TEXT}' => $agenttext,
        '{TAGS}' => $tags,
        '{CORE_CONCEPTS}' => $core_concepts_str,
        '{RELATED_CONCEPTS}' => $related_concepts_str
    ];
    
    $system_prompt = str_replace(
        array_keys($placeholders),
        array_values($placeholders),
        $prompt_template
    );
    
    // ==================== BUILD PAYLOAD (NON-STREAMING) ====================
    
    $payload = [
        'messages' => [
            ['role' => 'system', 'content' => $system_prompt],
            ['role' => 'user', 'content' => "Generate {$question_count} MCQs on: {$agenttext}"]
        ],
        'stream' => false,
        'max_tokens' => $question_count * 300,
        'temperature' => 0.4,
        'top_p' => 0.9
    ];
    
    // ==================== CALL LLM API ====================
    
    error_log("MCQ Widget - Starting API call: Level={$level}, Subject={$mainsubjectkey}, Count={$question_count}");
    
    $start_time = microtime(true);
    
    $response_text = local_ai_functions_call_endpoint($agentkey, 'mcq', $payload);
    
    $api_duration = round((microtime(true) - $start_time) * 1000);
    
    error_log('MCQ Widget - API call completed in ' . $api_duration . 'ms');
    
    if (!$response_text) {
        throw new Exception('Empty response from LLM API');
    }
    
    // ==================== PARSE API RESPONSE ====================
    
    $response_data = json_decode($response_text, true);
    
    if (json_last_error() !== JSON_ERROR_NONE) {
        throw new Exception('API response is not valid JSON: ' . json_last_error_msg());
    }
    
    // Extract text content
    $full_text = '';
    
    if (isset($response_data['choices'][0]['message']['content'])) {
        $full_text = $response_data['choices'][0]['message']['content'];
    } elseif (isset($response_data['content'])) {
        $full_text = $response_data['content'];
    } elseif (isset($response_data['error'])) {
        throw new Exception('API Error: ' . $response_data['error']);
    } else {
        throw new Exception('Unknown API response format');
    }
    
    if (empty($full_text)) {
        throw new Exception('No text content in API response');
    }
    
    error_log('MCQ Widget - Extracted text length: ' . strlen($full_text) . ' chars');
    
    // ==================== PARSE TEXT TO JSON ====================
    
    $mcq_data = parse_mcq_text_to_json($full_text);
    
    if (!$mcq_data || !isset($mcq_data['questions']) || count($mcq_data['questions']) === 0) {
        error_log('MCQ Widget - Parser failed. Text preview: ' . substr($full_text, 0, 500));
        throw new Exception('Failed to parse MCQ text into structured format.');
    }
    
    $questions_parsed = count($mcq_data['questions']);
    error_log('MCQ Widget - Successfully parsed ' . $questions_parsed . ' questions');
    
    // ==================== ADD METADATA ====================
    
    $mcq_data['metadata'] = [
        'level' => $level,
        'count' => $questions_parsed,
        'subject' => $subject,
        'topic' => $topic,
        'lesson' => $lesson,
        'target_exam' => $target,
        'agent_text' => $agenttext,
        'tags' => $tags,
        'main_subject_key' => $mainsubjectkey,
        'prompt_file' => $mcqinstruction,
        'core_concepts' => $core_concepts_array,
        'related_concepts' => $related_concepts_array,
        'is_dummy' => false,
        'generated_at' => time(),
        'api_duration_ms' => $api_duration,
        'format_version' => '1.0'
    ];
    
    // ==================== STORE JSON IN DATABASE ====================
    
    $usertext = strtoupper($level) . " MCQ: " . $agenttext;
    $json_response = json_encode($mcq_data, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
    
    $history_record = new stdClass();
    $history_record->userid = $USER->id;
    $history_record->courseid = $courseid;
    $history_record->usertext = $usertext;
    $history_record->botresponse = $json_response;
    $history_record->functioncalled = 'mcq_widget';
    $history_record->subject = $subject;
    $history_record->topic = $topic;
    $history_record->lesson = $lesson;
    $history_record->timecreated = time();
    $history_record->timemodified = time();
    
    $history_id = $DB->insert_record('block_ai_assistant_history', $history_record);
    
    error_log('MCQ Widget - Stored to database (history_id: ' . $history_id . ')');
    
    $mcq_data['metadata']['history_id'] = $history_id;
    
    // ==================== RETURN SUCCESS ====================
    
    echo json_encode([
        'status' => 'success',
        'data' => $mcq_data
    ], JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
    
} catch (Exception $e) {
    error_log('MCQ Widget Error: ' . $e->getMessage());
    error_log('MCQ Widget Error Location: ' . $e->getFile() . ':' . $e->getLine());
    
    http_response_code(500);
    echo json_encode([
        'status' => 'error',
        'message' => $e->getMessage(),
        'code' => 'MCQ_GENERATION_ERROR'
    ], JSON_PRETTY_PRINT);
}

// ==================== TEXT PARSER FUNCTION ====================

/**
 * Parse MCQ text format to JSON structure
 * Handles format: Q1. ... A. ... B. ... **Answer: A** **Explanation:** ...
 * 
 * @param string $text Raw MCQ text from LLM
 * @return array Structured MCQ data with questions array
 */
function parse_mcq_text_to_json($text) {
    $questions = [];
    
    // Remove "**DONE**" marker if present
    $text = str_replace('**DONE**', '', $text);
    $text = trim($text);
    
    // Split by horizontal line separator (---) or question pattern
    $parts = preg_split('/(^|\n)(?=Q\d+\.)/m', $text);
    
    foreach ($parts as $part) {
        $part = trim($part);
        if (empty($part)) continue;
        
        // Extract question number
        if (!preg_match('/^Q(\d+)\.\s*/i', $part, $q_num_match)) {
            continue;
        }
        
        $question_num = (int)$q_num_match[1];
        
        // Remove the Q1. prefix
        $part = preg_replace('/^Q\d+\.\s*/i', '', $part);
        
        // Split by separator (---)
        $sections = preg_split('/\n---+\n/s', $part);
        $question_section = trim($sections[0]);
        
        // Extract question text (everything before options A.)
        if (!preg_match('/^(.+?)(?=\s*\n\s*A\.)/s', $question_section, $q_text_match)) {
            error_log("MCQ Parser - Could not extract question text for Q{$question_num}");
            continue;
        }
        
        $question_text = trim($q_text_match[1]);
        
        // Extract options A. B. C. D.
        $options = [];
        $option_pattern = '/([A-D])\.\s*(.+?)(?=\s*\n\s*[A-D]\.|$|\*\*Answer)/s';
        
        if (preg_match_all($option_pattern, $question_section, $opt_matches, PREG_SET_ORDER)) {
            foreach ($opt_matches as $opt) {
                $option_text = trim($opt[2]);
                // Clean up option text
                $option_text = preg_replace('/\s+/', ' ', $option_text);
                $options[] = $option_text;
            }
        }
        
        // Extract correct answer: **Answer: A**
        $correct = '';
        if (preg_match('/\*\*Answer:\s*([A-D])\*\*/i', $question_section, $ans_match)) {
            $correct = strtoupper(trim($ans_match[1]));
        }
        
        // Extract explanation: **Explanation:** ...
        $explanation = '';
        if (preg_match('/\*\*Explanation:\*\*\s*(.+?)$/s', $question_section, $exp_match)) {
            $explanation = trim($exp_match[1]);
            
            // Clean up explanation
            $explanation = preg_replace('/^\s*[-â€¢]\s*/m', '', $explanation);
            $explanation = preg_replace('/\n{3,}/', "\n\n", $explanation);
            $explanation = rtrim($explanation, '-');
            $explanation = trim($explanation);
        }
        
        // Validate question structure
        $is_valid = true;
        $errors = [];
        
        if (empty($question_text)) {
            $errors[] = 'Missing question text';
            $is_valid = false;
        }
        
        if (count($options) < 4) {
            $errors[] = 'Less than 4 options (' . count($options) . ' found)';
            $is_valid = false;
        }
        
        if (empty($correct) || !preg_match('/^[A-D]$/', $correct)) {
            $errors[] = 'Invalid or missing correct answer';
            $is_valid = false;
        }
        
        if (empty($explanation)) {
            $explanation = 'No explanation provided.';
            error_log("MCQ Parser - Warning: Q{$question_num} has no explanation");
        }
        
        if ($is_valid) {
            $questions[] = [
                'question' => $question_text,
                'options' => array_slice($options, 0, 4),
                'correct' => $correct,
                'explanation' => $explanation
            ];
            
            error_log("MCQ Parser - Successfully parsed Q{$question_num}");
        } else {
            error_log("MCQ Parser - Skipping invalid Q{$question_num}: " . implode(', ', $errors));
        }
    }
    
    return ['questions' => $questions];
}
