{{! FILE: moodle/blocks/ai_assistant/templates/main.mustache }}
{{! MODIFIED: Changed hierarchy from Subject->Lesson->Topic to Subject->Topic->Lesson }}
<!-- Dependencies -->
<script src="https://cdn.jsdelivr.net/npm/markdown-it@12.3.2/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">
<!-- HTML Structure -->
<div class="ai-assistant-container">
  <!-- Shared overlay for fullscreen and modal -->
  <div id="ai-assistant-overlay"></div>
  <!-- Main Chat Widget -->
  <div id="ai-assistant-widget-container" class="ai-assistant-widget-window">
    <div class="ai-assistant-widget-header">
      <span id="ai-assistant-widget-title">AI Assistant</span>
      <div class="controls">
        <button id="ai-assistant-guided-search-button" class="ai-assistant-widget-control-button" aria-label="Guided Search">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z" />
            <path d="M3.5 8.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5z" />
          </svg>
        </button>
        <button id="ai-assistant-fullscreen-button" class="ai-assistant-widget-control-button" aria-label="Toggle fullscreen">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z" />
          </svg>
        </button>
        <button id="ai-assistant-close-button" class="ai-assistant-widget-control-button" aria-label="Close chat">&times;</button>
      </div>
    </div>
    <div id="ai-assistant-chat-body" class="ai-assistant-chat-body"></div>
    <div class="ai-assistant-input-area">
      <textarea id="ai-assistant-input" placeholder="Type a message..." aria-label="Chat input" rows="1"></textarea>
      <button id="ai-assistant-send-button" class="ai-assistant-send-button" aria-label="Send message">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="22" y1="2" x2="11" y2="13"></line>
          <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>
      </button>
    </div>
  </div>
  <!-- Main Floating Action Button -->
  <button id="ai-assistant-trigger-button" class="ai-assistant-widget-button" aria-label="Open AI Assistant">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="m3 21 1.9-5.7a8.5 8.5 0 1 1 3.8 3.8z"></path>
    </svg>
  </button>
  <!-- Guided Search Modal (MODIFIED: Subject -> Topic -> Lesson) -->
  <div id="ai-assistant-modal-container" class="ai-assistant-modal-container">
    <form id="ai-assistant-modal-form" class="ai-assistant-modal-form">
      <h3>Guided Search</h3>
      <p>Select a subject, topic, and lesson to get a more accurate answer.</p>
      <div class="form-group">
        <label for="ai-assistant-modal-subject">Subject</label>
        <select id="ai-assistant-modal-subject" name="subject" required>
          <option value="">-- Please select a subject --</option>
        </select>
      </div>
      <div class="form-group">
        <label for="ai-assistant-modal-topic">Topic</label>
        <select id="ai-assistant-modal-topic" name="topic" required disabled>
          <option value="">-- Please select a topic --</option>
        </select>
      </div>
      <div class="form-group">
        <label for="ai-assistant-modal-lesson">Lesson</label>
        <select id="ai-assistant-modal-lesson" name="lesson" required disabled>
          <option value="">-- Please select a lesson --</option>
        </select>
      </div>
      <div class="form-group">
        <label for="ai-assistant-modal-question">Your Question</label>
        <textarea id="ai-assistant-modal-question" name="question" rows="4" required placeholder="e.g., Explain the structural features of..."></textarea>
      </div>
      <div class="form-actions">
        <button type="button" id="ai-assistant-modal-cancel" class="ai-assistant-button-secondary">Cancel</button>
        <button type="submit" id="ai-assistant-modal-submit" class="ai-assistant-button-primary">Ask AI</button>
      </div>
    </form>
  </div>
</div>
<script>
  // Guard clause to prevent re-declaration errors
  if (!window.aiAssistantInitialized) {
    (function() {
      // --- Moodle Data and DOM Elements ---
      const agentConfigKey = '{{agentkey}}';
      const mainSubjectKey = '{{mainsubjectkey}}';
      const sesskey = '{{sesskey}}';
      const courseid = {{courseid}};
      const historyAjaxUrl = '{{historyajaxurl}}';
      const syllabusAjaxUrl = '{{syllabusajaxurl}}';
      const askAgentAjaxUrl = '{{askagentajaxurl}}';
      const pageSubject = '{{pagesubject}}';
      const pageTopic = '{{pagetopic}}';
      const functionUrls = {
        ask_agent: askAgentAjaxUrl
      };
      const triggerButton = document.getElementById('ai-assistant-trigger-button');
      const closeButton = document.getElementById('ai-assistant-close-button');
      const fullscreenButton = document.getElementById('ai-assistant-fullscreen-button');
      const guidedSearchButton = document.getElementById('ai-assistant-guided-search-button');
      const widgetContainer = document.getElementById('ai-assistant-widget-container');
      const chatBody = document.getElementById('ai-assistant-chat-body');
      const chatInput = document.getElementById('ai-assistant-input');
      const sendButton = document.getElementById('ai-assistant-send-button');
      const overlay = document.getElementById('ai-assistant-overlay');
      const modalContainer = document.getElementById('ai-assistant-modal-container');
      const modalForm = document.getElementById('ai-assistant-modal-form');
      const modalSubject = document.getElementById('ai-assistant-modal-subject');
      const modalTopic = document.getElementById('ai-assistant-modal-topic');
      const modalLesson = document.getElementById('ai-assistant-modal-lesson');
      const modalQuestion = document.getElementById('ai-assistant-modal-question');
      const modalCancel = document.getElementById('ai-assistant-modal-cancel');
      if (!window.aiAssistantState) {
        window.aiAssistantState = {
          isChatVisible: false,
          isFullscreen: false,
          isModalVisible: false,
          messageHistory: [],
          pendingHistoryId: null,
          nextMessageContext: {
            subject: '',
            topic: pageTopic,
            lesson: ''
          },
          syllabusData: null
        };
      }
      const agentState = window.aiAssistantState;
      // --- Core UI Functions ---
      const markdown = window.markdownit({
        html: true,
        breaks: true
      });
      // FIXED: Returns object with placeholders
const renderLatex = (text) => {
    const latexPlaceholders = new Map();
    
    // Display math \[...\]
    text = text.replace(/\\\[([\s\S]*?)\\\]/g, (match, latex) => {
        try {
            const rendered = katex.renderToString(latex.trim(), { displayMode: true, throwOnError: false });
            const placeholder = `@@KATEX_DISPLAY_${latexPlaceholders.size}@@`;
            latexPlaceholders.set(placeholder, rendered);
            return placeholder;
        } catch (e) {
            console.error('KaTeX display error:', e);
            return match;
        }
    });
    
    // Inline math \(...\)
    text = text.replace(/\\\(([\s\S]*?)\\\)/g, (match, latex) => {
        try {
            const rendered = katex.renderToString(latex.trim(), { displayMode: false, throwOnError: false });
            const placeholder = `@@KATEX_INLINE_${latexPlaceholders.size}@@`;
            latexPlaceholders.set(placeholder, rendered);
            return placeholder;
        } catch (e) {
            console.error('KaTeX inline error:', e);
            return match;
        }
    });
    
    return { text, placeholders: latexPlaceholders };  // â† Returns OBJECT now
};
      const renderMessage = (text, from) => {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'ai-assistant-message from-' + from;
    const avatar = document.createElement('div');
    avatar.className = 'ai-assistant-avatar';
    avatar.textContent = from === 'user' ? 'U' : 'A';
    const contentDiv = document.createElement('div');
    contentDiv.className = 'ai-assistant-message-content';
    
    // FIXED: Use new renderLatex that returns object
    const { text: protectedText, placeholders } = renderLatex(text);
    let renderedContent = markdown.render(protectedText);
    
    // Restore LaTeX
    placeholders.forEach((rendered, placeholder) => {
        renderedContent = renderedContent.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), rendered);
    });
    
    contentDiv.innerHTML = renderedContent;
    messageDiv.appendChild(avatar);
    messageDiv.appendChild(contentDiv);
    chatBody.appendChild(messageDiv);
    chatBody.scrollTop = chatBody.scrollHeight;
};
      const repaintHistory = () => {
        chatBody.innerHTML = '';
        agentState.messageHistory.forEach(msg => {
          renderMessage(msg.usertext, 'user');
          if (msg.botresponse) {
            renderMessage(msg.botresponse, 'bot');
          }
        });
      };
      const showTypingIndicator = () => {
        if (document.getElementById('ai-assistant-typing-indicator')) return;
        const indicator = document.createElement('div');
        indicator.id = 'ai-assistant-typing-indicator';
        indicator.className = 'ai-assistant-message from-bot';
        indicator.innerHTML = '<div class="ai-assistant-avatar">A</div><div class="ai-assistant-typing-indicator"><span></span><span></span><span></span></div>';
        chatBody.appendChild(indicator);
        chatBody.scrollTop = chatBody.scrollHeight;
      };
      const hideTypingIndicator = () => {
        const indicator = document.getElementById('ai-assistant-typing-indicator');
        if (indicator) indicator.remove();
      };
      const openChatWindow = () => {
        agentState.isChatVisible = true;
        widgetContainer.classList.add('active');
      };
      const closeChatWindow = () => {
        if (agentState.isFullscreen) {
          agentState.isFullscreen = false;
          widgetContainer.classList.remove('fullscreen');
          overlay.classList.remove('active');
        }
        agentState.isChatVisible = false;
        widgetContainer.classList.remove('active');
      };
      const openModal = () => {
        agentState.isModalVisible = true;
        overlay.classList.add('active');
        modalContainer.classList.add('active');
      };
      const closeModal = () => {
        agentState.isModalVisible = false;
        overlay.classList.remove('active');
        modalContainer.classList.remove('active');
      };
      // --- Communication and Data Functions (STREAMING VERSION with EventSource) ---
const sendMessage = (detail) => {
    if (detail.agentText && !detail.agent_text) {
        detail.agent_text = detail.agentText;
    }
    const functionCalled = detail.function;
    const userText = detail.agent_text;
    if (!userText || !userText.trim() || !functionCalled) { return; }

    renderMessage(userText, 'user');
    showTypingIndicator();

    // Build history entry
    const historyEntry = {
        usertext: userText,
        botresponse: '',
        functioncalled: functionCalled,
        subject: detail.subject || '',
        topic: detail.topic || agentState.nextMessageContext.topic || '',
        lesson: detail.lesson || '',
    };

    agentState.messageHistory.push(historyEntry);
    localStorage.setItem(`ai_assistant_history_${courseid}`, JSON.stringify(agentState.messageHistory));

    // Create history record first
    const createPayload = {
        action: 'create',
        sesskey: sesskey,
        courseid: courseid,
        history: historyEntry
    };

    fetch(historyAjaxUrl, { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(createPayload)
    })
    .then(response => response.json())
    .then(createData => {
        if (createData.status !== 'success' || !createData.historyid) {
            throw new Error(createData.message || 'Failed to create history record.');
        }
        const historyId = createData.historyid;
        
        // Build EventSource URL with query parameters
        const agentParams = new URLSearchParams();
        agentParams.append('sesskey', sesskey);
        agentParams.append('agent_config_key', agentConfigKey);
        agentParams.append('agent_text', userText);
        
        // Add all context parameters
        if (detail.target) agentParams.append('target', detail.target);
        if (detail.subject) agentParams.append('subject', detail.subject);
        if (detail.topic) agentParams.append('topic', detail.topic);
        if (detail.lesson) agentParams.append('lesson', detail.lesson);
        if (detail.tags) {
            const tagsToSend = Array.isArray(detail.tags) ? detail.tags.join(',') : detail.tags;
            agentParams.append('tags', tagsToSend);
        }
        
        const endpointUrl = functionUrls[functionCalled] + '?' + agentParams.toString();
        
        // --- Setup EventSource for SSE Streaming ---
        const eventSource = new EventSource(endpointUrl);
        let streamedContent = '';
        let metadata = {};
        
        // Create bot message element for real-time updates
        hideTypingIndicator();
        const messageDiv = document.createElement('div');
        messageDiv.className = 'ai-assistant-message from-bot';
        messageDiv.id = `streaming-message-${historyId}`;
        
        const avatar = document.createElement('div');
        avatar.className = 'ai-assistant-avatar';
        avatar.textContent = 'A';
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'ai-assistant-message-content';
        contentDiv.innerHTML = '<em class="text-muted">Thinking...</em>';
        
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(contentDiv);
        chatBody.appendChild(messageDiv);
        chatBody.scrollTop = chatBody.scrollHeight;
        
        // Handle incoming chunks
        // Handle incoming chunks - FIXED for kimi-k2-thinking model
eventSource.addEventListener('chunk', (e) => {
    console.log('Raw SSE data:', e.data);  // Debug log
    
    const chunk = JSON.parse(e.data);
    
    // Extract content from the API response
    let newContent = '';
    
    if (chunk.choices && chunk.choices[0] && chunk.choices[0].delta) {
        const delta = chunk.choices[0].delta;
        
        // kimi-k2-thinking sends text in 'reasoning' field during thinking
        if (delta.reasoning) {
            newContent = delta.reasoning;
        }
        // Regular content (comes after thinking is done)
        else if (delta.content) {
            newContent = delta.content;
        }
    }
    
    if (newContent) {
        streamedContent += newContent;
        
        // Render with LaTeX support
        const { text: protectedText, placeholders } = renderLatex(streamedContent);
        let renderedContent = markdown.render(protectedText);
        
        // Restore LaTeX placeholders
        placeholders.forEach((rendered, placeholder) => {
            const escapedPlaceholder = placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            renderedContent = renderedContent.replace(new RegExp(escapedPlaceholder, 'g'), rendered);
        });
        
        contentDiv.innerHTML = renderedContent;
        chatBody.scrollTop = chatBody.scrollHeight;
    }
});
        
        // Handle metadata from server
        eventSource.addEventListener('metadata', (e) => {
            metadata = JSON.parse(e.data);
        });
        
        // Handle stream completion
        eventSource.addEventListener('done', () => {
            eventSource.close();
            
            // Update local history
            const lastMessage = agentState.messageHistory[agentState.messageHistory.length - 1];
            if (lastMessage) {
                lastMessage.botresponse = streamedContent;
            }
            localStorage.setItem(`ai_assistant_history_${courseid}`, JSON.stringify(agentState.messageHistory));
            
            // Save to database with metadata
            const updatePayload = {
                action: 'update',
                sesskey: sesskey,
                courseid: courseid,
                historyid: historyId,
                botresponse: streamedContent,
                metadata: metadata
            };
            
            fetch(historyAjaxUrl, { 
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updatePayload)
            }).catch(err => console.error('Failed to update history:', err));
        });
        
        // Handle errors from EventSource
        eventSource.addEventListener('error', (e) => {
            console.error('EventSource error:', e);
            eventSource.close();
            hideTypingIndicator();
            
            // Try to parse error data if available
            if (e.data) {
                try {
                    const error = JSON.parse(e.data);
                    contentDiv.innerHTML = `<span class="text-danger">Error: ${error.error}</span>`;
                } catch {
                    contentDiv.innerHTML = `<span class="text-danger">Connection error. Please try again.</span>`;
                }
            } else {
                contentDiv.innerHTML = `<span class="text-danger">Connection error. Please try again.</span>`;
            }
            
            chatBody.scrollTop = chatBody.scrollHeight;
        });
        
        // Also listen for generic 'error' event type
        eventSource.onerror = (e) => {
            console.error('EventSource connection error:', e);
            eventSource.close();
            hideTypingIndicator();
            contentDiv.innerHTML = `<span class="text-danger">Connection lost. Please try again.</span>`;
            chatBody.scrollTop = chatBody.scrollHeight;
        };
        
    })
    .catch(error => {
        console.error("AI Assistant error:", error);
        hideTypingIndicator();
        renderMessage(`Sorry, a critical error occurred: ${error.message}`, 'bot');
    });

    chatInput.value = '';
    chatInput.style.height = 'auto';
};

      // MODIFIED: Updated to send empty subject and lesson
      const handleTextInput = () => {
        sendMessage({
          function: 'ask_agent',
          agent_text: chatInput.value,
          subject: '',
          topic: pageTopic,
          lesson: ''
        });
      };
      const loadSyllabus = async () => {
        if (agentState.syllabusData) return;
        try {
          const response = await fetch(syllabusAjaxUrl + '?mainsubject=' + mainSubjectKey + '&sesskey=' + sesskey);
          agentState.syllabusData = await response.json();
        } catch (error) {
          console.error("Failed to load syllabus:", error);
        }
      };
      // --- Initialization ---
      const init = () => {
        widgetContainer.style.display = '';
        modalContainer.style.display = '';
        const cachedHistory = localStorage.getItem('ai_assistant_history_' + courseid);
        if (cachedHistory) {
          try {
            agentState.messageHistory = JSON.parse(cachedHistory);
          } catch (e) {
            agentState.messageHistory = [];
          }
        }
        repaintHistory();
        triggerButton.addEventListener('click', () => {
          if (agentState.isChatVisible) {
            closeChatWindow();
          } else {
            openChatWindow();
          }
        });
        closeButton.addEventListener('click', closeChatWindow);
        fullscreenButton.addEventListener('click', () => {
          agentState.isFullscreen = !agentState.isFullscreen;
          widgetContainer.classList.toggle('fullscreen', agentState.isFullscreen);
          overlay.classList.toggle('active', agentState.isFullscreen);
        });
        sendButton.addEventListener('click', handleTextInput);
        chatInput.addEventListener('keypress', e => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            handleTextInput();
          }
        });
        chatInput.addEventListener('input', () => {
          chatInput.style.height = 'auto';
          chatInput.style.height = (chatInput.scrollHeight) + 'px';
        });
        document.addEventListener('ai-assistant-send', (e) => {
          if (!agentState.isChatVisible) openChatWindow();
          setTimeout(() => sendMessage(e.detail), agentState.isChatVisible ? 0 : 300);
        });
        // MODIFIED: Guided Search Modal - Load syllabus and populate dropdowns
        guidedSearchButton.addEventListener('click', async () => {
          await loadSyllabus();
          if (!agentState.syllabusData) {
            alert('Could not load syllabus data.');
            return;
          }
          modalSubject.innerHTML = '<option value="">-- Please select a subject --</option>';
          agentState.syllabusData.forEach(sub => {
            const option = document.createElement('option');
            option.value = sub.subject_key;
            option.textContent = sub.subject;
            modalSubject.appendChild(option);
          });
          modalTopic.innerHTML = '<option value="">-- Please select a topic --</option>';
          modalLesson.innerHTML = '<option value="">-- Please select a lesson --</option>';
          modalTopic.disabled = true;
          modalLesson.disabled = true;
          openModal();
        });
        // MODIFIED: Subject change -> populate Topics
        modalSubject.addEventListener('change', () => {
          const selectedSubjectKey = modalSubject.value;
          modalTopic.innerHTML = '<option value="">-- Please select a topic --</option>';
          modalLesson.innerHTML = '<option value="">-- Please select a lesson --</option>';
          modalTopic.disabled = true;
          modalLesson.disabled = true;
          const subjectData = agentState.syllabusData.find(s => s.subject_key === selectedSubjectKey);
          if (subjectData && subjectData.topics) {
            subjectData.topics.forEach(topic => {
              const option = document.createElement('option');
              option.value = topic.topic_key;
              option.textContent = topic.topic;
              modalTopic.appendChild(option);
            });
            modalTopic.disabled = false;
          }
        });
        // MODIFIED: Topic change -> populate Lessons
        modalTopic.addEventListener('change', () => {
          const selectedSubjectKey = modalSubject.value;
          const selectedTopicKey = modalTopic.value;
          modalLesson.innerHTML = '<option value="">-- Please select a lesson --</option>';
          modalLesson.disabled = true;
          const subjectData = agentState.syllabusData.find(s => s.subject_key === selectedSubjectKey);
          const topicData = subjectData ? subjectData.topics.find(t => t.topic_key === selectedTopicKey) : null;
          if (topicData && topicData.lessons) {
            topicData.lessons.forEach(lesson => {
              const option = document.createElement('option');
              option.value = lesson.lesson_key;
              option.textContent = lesson.lesson;
              modalLesson.appendChild(option);
            });
            modalLesson.disabled = false;
          }
        });
        // MODIFIED: Form submit - extract Subject -> Topic -> Lesson
        modalForm.addEventListener('submit', (e) => {
          e.preventDefault();
          const selectedSubjectKey = modalSubject.value;
          const selectedTopicKey = modalTopic.value;
          const selectedLessonKey = modalLesson.value;
          const subjectData = agentState.syllabusData.find(s => s.subject_key === selectedSubjectKey);
          const topicData = subjectData ? subjectData.topics.find(t => t.topic_key === selectedTopicKey) : null;
          const lessonData = topicData ? topicData.lessons.find(l => l.lesson_key === selectedLessonKey) : null;
          const tagsForQuery = lessonData ? lessonData.tags : [];
          sendMessage({
            function: 'ask_agent',
            agent_text: modalQuestion.value,
            subject: selectedSubjectKey,
            topic: selectedTopicKey,
            lesson: selectedLessonKey,
            tags: tagsForQuery
          });
          modalForm.reset();
          closeModal();
          if (!agentState.isChatVisible) openChatWindow();
        });
        modalCancel.addEventListener('click', closeModal);
      };
      init();
    })();
    // Set the flag to true after the first successful execution.
    window.aiAssistantInitialized = true;
  }
</script>